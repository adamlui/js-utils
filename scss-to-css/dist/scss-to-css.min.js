const c=require("fs"),t=require("path"),n=require("sass");function l(o,s={}){var e={recursive:!0,verbose:!0,dotFolders:!1};if("string"!=typeof o)return console.error("findSCSS() » ERROR: 1st arg <searchDir> must be a string.");var r=t.resolve(process.cwd(),o);if(c.existsSync(r)){if(f(s,e,"findSCSS('assets/scss', { verbose: false, dotFolders: true })")){s={...e,...s};const i=c.readdirSync(o),n=[];return s.verbose&&!s.isRecursing&&console.info("findSCSS() » Searching for SCSS files..."),i.forEach(e=>{var r=t.resolve(o,e);c.statSync(r).isDirectory()&&"node_modules"!=e&&(s.dotFolders||!e.startsWith("."))&&s.recursive?n.push(...l(r,{...s,isRecursing:!0})):e.endsWith(".scss")&&n.push(r)}),!s.isRecursing&&s.verbose&&(console.info("findSCSS() » Search complete! "+(0===n.length?"No":n.length)+` file${0==n.length||1<n.length?"s":""} found.`),"compile"===l.caller.name||require.main.filename.endsWith("cli.js")||console.info("findSCSS() » Check returned array.")),s.isRecursing||0<n.length?n:[]}}else console.error("findSCSS() » ERROR: 1st arg <searchDir> must be an existing directory."),console.error(`findSCSS() » ${r} does not exist.`)}function e(e,o={}){var r={recursive:!0,verbose:!0,dotFolders:!1,minify:!0,sourceMaps:!0};if("string"!=typeof e)return console.error("compile() » ERROR: 1st arg <inputPath> must be a string.");if(e=t.resolve(process.cwd(),e),c.existsSync(e)){if(f(o,r,"compile('assets/scss', { recursive: false, minify: false })")){const i={style:(o={...r,...o}).minify?"compressed":"expanded",sourceMap:o.sourceMaps};if(c.existsSync(e)){if(!e.endsWith(".scss"))return r=l(e,{recursive:o.recursive,verbose:o.verbose,dotFolders:o.dotFolders})?.map(e=>{o.verbose&&console.info(`compile() » Compiling ${e}...`);try{var r=n.compile(e,i);return{code:r.css,srcMap:r.sourceMap,srcPath:e}}catch(e){return console.error(`
compile() » ERROR: ${e.message}
`),{error:e}}}).filter(e=>!e.error),o.verbose&&(0<r.length?console.info("compile() » Compilation complete. Check returned object."):console.info("compile() » No SCSS files processed.")),r;o.verbose&&console.info(`compile() » Compiling ${e}...`);try{var s=n.compile(e,i);return o.verbose&&!require.main.filename.endsWith("cli.js")&&console.info("compile() » Compilation complete. Check returned object."),{code:s.css,srcMap:s.sourceMap,srcPath:t.resolve(process.cwd(),e)}}catch(e){return console.error(`
compile() » ERROR: ${e.message}
`),{error:e}}}}}else console.error("compile() » ERROR: 1st arg <inputPath> must be an existing directory or file."),console.error(`compile() » ${e} does not exist.`)}function f(e,r,o){const s=(f.caller?.name||"validateOptions")+"() » ",i=JSON.stringify(r,null,2).replace(/"([^"]+)":/g,"$1:").replace(/"/g,"'").replace(/\n\s*/g," "),n=Object.keys(r).join(", "),c=Object.keys(r).filter(e=>"boolean"==typeof r[e]),t=Object.keys(r).filter(e=>Number.isInteger(r[e]));var l=()=>{console.info(s+`Valid options: [ ${n} ]`),console.info(s+"If omitted, default settings are: "+i)};if("object"!=typeof e)return console.error(s+"ERROR: [options] can only be an object of key/values."),console.info(s+"Example valid call: "+o),l(),!1;for(const a in e){if("isRecursing"!=a&&!Object.prototype.hasOwnProperty.call(r,a))return console.error(s+`ERROR: \`${a}\` is an invalid option.`),l(),!1;if(c.includes(a)&&"boolean"!=typeof e[a])return console.error(s+`ERROR: [${a}] option can only be \`true\` or \`false\`.`),!1;if(t.includes(a)&&(e[a]=parseInt(e[a],10),isNaN(e[a])||e[a]<1))return console.error(s+`ERROR: [${a}] option can only be an integer > 0.`),!1}return!0}module.exports={compile:e,findSCSS:l};