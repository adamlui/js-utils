const f=require("fs"),p=require("path"),a=require("sass");function d(r,s={}){var e={recursive:!0,verbose:!0,dotFolders:!1};if("string"!=typeof r)return console.error("findSCSS() » ERROR: 1st arg <searchDir> must be a string.");var o=p.resolve(process.cwd(),r);if(f.existsSync(o)){const i=JSON.stringify(e,null,2).replace(/"([^"]+)":/g,"$1:").replace(/"/g,"'").replace(/\n\s*/g," "),c=Object.keys(e).join(", ");var n=()=>{console.info(`findSCSS() » Valid options: [ ${c} ]`),console.info("findSCSS() » If omitted, default settings are: "+i)};if("object"==typeof s){for(const a in s){if(!Object.prototype.hasOwnProperty.call(e,a)&&"isRecursing"!==a)return console.error(`findSCSS() » ERROR: \`${a}\` is an invalid option.`),void n();if("boolean"!=typeof s[a])return console.error(`findSCSS() » ERROR: [${a}] option can only be \`true\` or \`false\`.`)}s={...e,...s};const t=f.readdirSync(r),l=[];return s.verbose&&!s.isRecursing&&console.info("findSCSS() » Searching for SCSS files..."),t.forEach(e=>{var o=p.resolve(r,e);f.statSync(o).isDirectory()&&"node_modules"!=e&&(s.dotFolders||!e.startsWith("."))&&s.recursive?l.push(...d(o,{...s,isRecursing:!0})):e.endsWith(".scss")&&l.push(o)}),!s.isRecursing&&s.verbose&&(console.info("findSCSS() » Search complete! "+(0===l.length?"No":l.length)+` file${1<l.length?"s":""} found.`),"compile"===d.caller.name||require.main.filename.endsWith("cli.js")||console.info("findSCSS() » Check returned array.")),s.isRecursing||0<l.length?l:[]}console.error("findSCSS() » ERROR: 2nd arg [options] can only be an object of key/values."),console.info("findSCSS() » Example valid call: findSCSS('assets/scss', { verbose: false, dotFolders: true })"),n()}else console.error("findSCSS() » ERROR: 1st arg <searchDir> must be an existing directory."),console.error(`findSCSS() » ${o} does not exist.`)}function e(e,r={}){var o={recursive:!0,verbose:!0,dotFolders:!1,minify:!0,sourceMaps:!0};if("string"!=typeof e)return console.error("compile() » ERROR: 1st arg <inputPath> must be a string.");if(e=p.resolve(process.cwd(),e),f.existsSync(e)){const i=JSON.stringify(o,null,2).replace(/"([^"]+)":/g,"$1:").replace(/"/g,"'").replace(/\n\s*/g," "),c=Object.keys(o).join(", ");var s=()=>{console.info(`compile() » Valid options: [ ${c} ]`),console.info("compile() » If omitted, default settings are: "+i)};if("object"!=typeof r)console.error("compile() » ERROR: 2nd [options] can only be an object of key/values."),console.info("compile() » Example valid call: compile('assets/scss', { recursive: false, minify: false })"),s();else{for(const l in r){if(!Object.prototype.hasOwnProperty.call(o,l))return console.error(`compile() » ERROR: \`${l}\` is an invalid option.`),void s();if("boolean"!=typeof r[l])return console.error(`compile() » ERROR: [${l}] option can only be \`true\` or \`false\`.`)}const t={style:(r={...o,...r}).minify?"compressed":"expanded",sourceMap:r.sourceMaps};if(f.existsSync(e)){if(!e.endsWith(".scss"))return d(e,{recursive:r.recursive,verbose:r.verbose,dotFolders:r.dotFolders})?.map(e=>{r.verbose&&console.info(`compile() » Compiling ${e}...`);try{var o=a.compile(e,t);return{code:o.css,srcMap:o.sourceMap,srcPath:e}}catch(e){return console.error(`
compile() » ERROR: ${e.message}
`),{error:e}}}).filter(e=>!e.error);r.verbose&&console.info(`compile() » Compiling ${e}...`);try{var n=a.compile(e,t);return{code:n.css,srcMap:n.sourceMap,srcPath:p.resolve(process.cwd(),e)}}catch(e){return console.error(`
compile() » ERROR: ${e.message}
`),{error:e}}}}}else console.error("compile() » ERROR: 1st arg <inputPath> must be an existing directory or file."),console.error(`compile() » ${e} does not exist.`)}module.exports={compile:e,findSCSS:d};