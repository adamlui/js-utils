#!/usr/bin/env node
const c=require("fs"),l=require("path"),t=require("sass");function a(s,r={}){var e={recursive:!0,verbose:!0,dotFolders:!1};if(r={...e,...r},!s)return console.error("findSCSS() Â» ERROR: Please supply a `searchDir` as 1st arg.");if("string"!=typeof s)return console.error("findSCSS() Â» ERROR: 1st arg `searchDir` must be a string.");var o=l.resolve(process.cwd(),s);if(!c.existsSync(o))return console.error("findSCSS() Â» ERROR: Arg `searchDir` must be an existing directory."+`
'${o}' does not exist.`);for(const t of Object.keys(r))if(!Object.prototype.hasOwnProperty.call(e,t)){if("isRecursing"!==t)return console.error(`findSCSS() Â» ERROR: \`${t}\` is an invalid option.`+`
findSCSS() Â» Valid options: [ ${Object.keys(e).join(", ")} ]`);if("boolean"!=typeof r[t])return console.error(`findSCSS() Â» ERROR: \`${t}\` option must be set to \`true\` or \`false\`.`)}const i=c.readdirSync(s),n=[];return r.verbose&&!r.isRecursing&&console.info("\nfindSCSS() Â» Searching for SCSS files..."),i.forEach(e=>{var o=l.resolve(s,e);c.statSync(o).isDirectory()&&"node_modules"!=e&&(r.dotFolders||!e.startsWith("."))&&r.recursive?n.push(...a(o,{...r,isRecursing:!0})):e.endsWith(".scss")&&n.push(o)}),!r.isRecursing&&r.verbose&&console.info("findSCSS() Â» Search complete. "+(0===n.length?"No":n.length)+` file${1<n.length?"s":""} found.`+("compile"!==a.caller.name?"\nfindSCSS() Â» Check returned object.":"")),r.isRecursing||0<n.length?n:[]}function s(e,s={}){var o={minify:!0,sourceMaps:!0,recursive:!0,verbose:!0,dotFolders:!1};if(s={...o,...s},"string"!=typeof e)return console.error("findSCSS() Â» ERROR: Arg `inputPath` must be a string.");if(e=l.resolve(process.cwd(),e),!c.existsSync(e))return console.error("findSCSS() Â» ERROR: Arg `inputPath` must be an existing directory or file."+`
findSCSS() Â» '${e}' does not exist.`);for(const n of Object.keys(s)){if(!Object.prototype.hasOwnProperty.call(o,n))return console.error(`compile() Â» ERROR: \`${n}\` is an invalid option.`+`
findSCSS() Â» Valid options: [ ${Object.keys(o).join(", ")} ]`);if("boolean"!=typeof s[n])return console.error(`compile() Â» ERROR: \`${n}\` option must be set to \`true\` or \`false\`.`)}const r={style:s.minify?"compressed":"expanded",sourceMap:s.sourceMaps};if(c.existsSync(e)){if(!e.endsWith(".scss"))return a(e,{recursive:s.recursive,verbose:s.verbose,dotFolders:s.dotFolders})?.map(e=>{s.verbose&&console.info(`compile() Â» Compiling ${e}...`);try{var o=t.compile(e,r);return console.info("compile() Â» Compilation complete! Check returned object."),{code:o.css,srcMap:o.sourceMap,srcPath:e}}catch(e){return console.error(`
compile() Â» ERROR: ${e.message}
`),{error:e}}}).filter(e=>!e.error);s.verbose&&console.info(`compile() Â» Compiling ${e}...`);try{var i=t.compile(e,r);return console.info("compile() Â» Compilation complete! Check returned object."),{code:i.css,srcMap:i.sourceMap,srcPath:l.resolve(process.cwd(),e)}}catch(e){return console.error(`
compile() Â» ERROR: ${e.message}
`),{error:e}}}}if(require.main!==module)module.exports={compile:s,findSCSS:a};else{const i="[0m",n="[1;91m",f="[1;33m",e="[1;92m",u={},p={dryRun:/^--?(?:n|dry-?run)$/,includeDotFolders:/^--?(?:dd?|(?:include-?)?dot-?(?:folder|dir(?:ector(?:y|ie))?)s?=?(?:true|1)?)$/,noSourceMaps:/^--?(?:S|(?:exclude|disable|no)-?so?u?rce?-?maps?|so?u?rce?-?maps?=(?:false|0))$/,noRecursion:/^--?(?:R|(?:disable|no)-?recursi(?:on|ve)|recursi(?:on|ve)=(?:false|0))$/,noMinify:/^--?(?:M|(?:disable|no)-?minif(?:y|ication)|minif(?:y|ication)=(?:false|0))$/,quietMode:/^--?q(?:uiet)?(?:-?mode)?$/,help:/^--?h(?:elp)?$/,version:/^--?ve?r?s?i?o?n?$/};if(process.argv.forEach(o=>{var e;o.startsWith("-")&&((e=Object.keys(p).find(e=>p[e].test(o)))?u[e]=!0:(console.error(`
${n}ERROR: Arg [${o}] not recognized.`+i),console.info(`
${f}Valid arguments are below.`+i),r(["configOptions","infoCmds"]),process.exit(1)))}),process.argv.some(e=>p.help.test(e)))r();else if(process.argv.some(e=>p.version.test(e)))console.info("v"+require("./package.json").version);else{const[d="",m=""]=process.argv.slice(2).filter(e=>!e.startsWith("-")).map(e=>e.replace(/^\/*/,"")),S=l.resolve(process.cwd(),d),h=(d&&!c.existsSync(S)&&(console.error(`
${n}Error: First argument must be an existing file or directory.`+`
'${S}' does not exist.`+i+`

${e}Example valid command: 
>> scss-to-css . output.min.css`+i+`

${f}For all command options: 
>> scss-to-css --help`+i),process.exit(1)),d.endsWith(".scss")?[S]:a(S,{recursive:!u.noRecursion,verbose:!u.quietMode}));if(u.dryRun)0<h.length?(console.info(`
${f}SCSS files to be compiled:`+i),h.forEach(e=>console.info(e))):console.info(f+`
No SCSS files will be compiled.`+i);else{const g=[],v=h.map(e=>{var o=s(e,{minify:!u.noMinify,sourceMaps:!u.noSourceMaps,verbose:!u.quietMode});return o.error&&g.push(e),o}).filter(e=>!e.error);if(v?.forEach(({code:e,srcMap:o,srcPath:s})=>{var r=l.join(l.dirname(s),/(?:src|s[ac]ss)$/.test(l.dirname(s))?"../css":m.endsWith(".css")?l.dirname(m):m||"css"),s=(m.endsWith(".css")&&d.endsWith(".scss")?l.basename(m).replace(/(\.min)?\.css$/,""):l.basename(s,".scss"))+".min.css",s=l.join(r,s);c.existsSync(r)||c.mkdirSync(r,{recursive:!0}),c.writeFileSync(s,e,"utf8"),u.noSourceMaps||c.writeFileSync(s+".map",JSON.stringify(o),"utf8")}),0<v?.length){const y=1<v.length?"s":"";o(`
${e}Compilation complete!`+i),o(v.length+" CSS file"+y+(u.noSourceMaps?"":` + ${v.length} source map`+y)+" generated.")}else o(f+"No SCSS files processed."+i);0<g.length&&(o(`
`+n+g.length+" file"+(1<g.length?"s":"")+" failed to compile:"+i),g.forEach(e=>o(e)))}}function r(e=["cmdFormat","pathArgs","configOptions","infoCmds"]){const o={cmdFormat:[`
${f}scss-to-css [inputPath] [outputPath] [options]`+i],pathArgs:["\nPath arguments:"," [inputPath]                 Path to SCSS file or directory containing SCSS files to be compiled, relative to the current working directory."," [outputPath]                Path to file or directory where CSS + sourcemap files will be stored, relative to original file location (if not provided, css/ is used)."],configOptions:["\nConfig options:"," -n, --dry-run                Don't actually compile the file(s), just show if they will be processed."," -d, --include-dotfolders     Include dotfolders in file search."," -S, --no-source-maps         Prevent source maps from being generated."," -M, --no-minify              Disable minification of output CSS."," -R, --no-recursion           Disable recursive file searching."," -q, --quiet                  Suppress all logging except errors."],infoCmds:["\nInfo commands:"," -h, --help                   Display help screen."," -v, --version                Show version number."]};e.forEach(e=>{o[e]?.forEach(e=>{{const r=process.stdout.columns||80,i=[],o=e.match(/\S+|\s+/g);let s="";o.forEach(e=>{var o=r-(0===i.length?0:30);s.length+e.length>o&&(i.push(0===i.length?s:s.trimStart()),s=""),s+=e}),i.push(0===i.length?s:s.trimStart()),i.forEach((e,o)=>console.info(0===o?e:" ".repeat(30)+e))}})})}function o(e){u.quietMode||console.info(e)}}