let d;try{d=require("crypto").randomInt}catch(e){const n=window.crypto||window.msCrypto;d=(e,o)=>{var r=n?.getRandomValues(new Uint32Array(1))[0]/4294967295||Math.random();return Math.floor(r*(o-e))+e}}const p={generate:function(o={}){const r={verbose:!0,qty:1},e=JSON.stringify(r,null,2).replace(/"([^"]+)":/g,"$1:").replace(/"/g,"'").replace(/\n\s*/g," "),n=Object.keys(r).join(", "),t=Object.keys(r).filter(e=>"boolean"==typeof r[e]),i=Object.keys(r).filter(e=>Number.isInteger(r[e]));var a=()=>{console.info(`ipv4.generate() » Valid options: [ ${n} ]`),console.info("ipv4.generate() » If omitted, default settings are: "+e)};if("object"==typeof o){for(const v in o){if(!Object.prototype.hasOwnProperty.call(r,v))return console.error(`ipv4.generate() » ERROR: \`${v}\` is an invalid option.`),void a();if(t.includes(v)&&"boolean"!=typeof o[v])return console.error(`ipv4.generate() » ERROR: [${v}] option can only be \`true\` or \`false\`.`);if(i.includes(v)&&(o[v]=parseInt(o[v],10),isNaN(o[v])||o[v]<1))return console.error(`ipv4.generate() » ERROR: [${v}] option can only be an integer > 0.`)}(o={...r,...o}).verbose&&console.info(`ipv4.generate() » Generating IPv4 address${1<o.qty?"es":""}...`);var s=[];if(1<o.qty)for(let e=0;e<o.qty;e++)s.push(this.generate({...o,qty:1,verbose:!1}));else{var l=[];for(let e=0;e<4;e++)l.push(d(0,256));s.push(l.join("."))}var p=1<o.qty?s:s[0];return o.verbose&&(console.info(`ipv4.generate() » IPv4 address${1<o.qty?"es":""} generated!`),1===o.qty?console.info("ipv4.generate() » "+p):"undefined"==typeof require||require.main.filename.endsWith("cli.js")||console.info("ipv4.generate() » Check returned array.")),p}console.error("ipv4.generate() » ERROR: [options] can only be an object of key/values."),console.info("ipv4.generate() » Example valid call: ipv4.generate({ verbose: false, qty: 3 })"),a()},validate:function(e,o={}){var r={verbose:!0};if("string"!=typeof e)return console.error("ipv4.validate() » ERROR: 1st arg <address> must be a string.");const n=JSON.stringify(r,null,2).replace(/"([^"]+)":/g,"$1:").replace(/"/g,"'").replace(/\n\s*/g," "),t=Object.keys(r).join(", ");var i=()=>{console.info(`ipv4.validate() » Valid options: [ ${t} ]`),console.info("ipv4.validate() » If omitted, default settings are: "+n)};if("object"==typeof o){for(const a in o){if(!Object.prototype.hasOwnProperty.call(r,a))return console.error(`ipv4.validate() » ERROR: \`${a}\` is an invalid option.`),void i();if("boolean"!=typeof o[a])return console.error(`ipv4.validate() » ERROR: [${a}] option can only be \`true\` or \`false\`.`)}(o={...r,...o}).verbose&&console.info("ipv4.validate() » Validating IPv4 address...");e=e.split("."),e=!(4!==e.length||e.some(e=>!/^\d+$/.test(e)||parseInt(e,10)<0||255<parseInt(e,10)));return o.verbose&&console.info(`ipv4.validate() » IP is ${e?"":"in"}valid IPv4 address!`),e}console.error("ipv4.validate() » ERROR: 2nd arg [options] can only be an object of key/values."),console.info("ipv4.validate() » Example valid call: ipv4.validate('0.0.255.255', { verbose: false })"),i()}},e={generate:function(o={}){const r={verbose:!0,qty:1,leadingZeros:!1,doubleColon:!0},e=JSON.stringify(r,null,2).replace(/"([^"]+)":/g,"$1:").replace(/"/g,"'").replace(/\n\s*/g," "),n=Object.keys(r).join(", "),t=Object.keys(r).filter(e=>"boolean"==typeof r[e]),i=Object.keys(r).filter(e=>Number.isInteger(r[e]));var a=()=>{console.info(`ipv6.generate() » Valid options: [ ${n} ]`),console.info("ipv6.generate() » If omitted, default settings are: "+e)};if("object"==typeof o){for(const p in o){if(!Object.prototype.hasOwnProperty.call(r,p))return console.error(`ipv6.generate() » ERROR: \`${p}\` is an invalid option.`),void a();if(t.includes(p)&&"boolean"!=typeof o[p])return console.error(`ipv6.generate() » ERROR: [${p}] option can only be \`true\` or \`false\`.`);if(i.includes(p)&&(o[p]=parseInt(o[p],10),isNaN(o[p])||o[p]<1))return console.error(`ipv6.generate() » ERROR: [${p}] option can only be an integer > 0.`)}(o={...r,...o}).verbose&&console.info(`ipv6.generate() » Generating IPv6 address${1<o.qty?"es":""}...`);var s=[];if(1<o.qty)for(let e=0;e<o.qty;e++)s.push(this.generate({...o,qty:1,verbose:!1}));else{const v=[],{qty:c,...f}=o;for(let e=0;e<8;e++){let o="";for(let e=0;e<4;e++)o+=d(0,16).toString(16);v.push(o)}s.push(this.format(v.join(":"),{...f,verbose:!1}))}var l=1<o.qty?s:s[0];return o.verbose&&(console.info(`ipv6.generate() » IPv6 address${1<o.qty?"es":""} generated!`),console.info(1===o.qty?"ipv6.generate() » "+l:"ipv6.generate() » Check returned array.")),l}console.error("ipv6.generate() » ERROR: [options] can only be an object of key/values."),console.info("ipv6.generate() » Example valid call: ipv6.generate({ leadingZeros: true, qty: 5 })"),a()},format:function(o,r={}){var n={verbose:!0,leadingZeros:!1,doubleColon:!0};if("string"!=typeof o)return console.error("ipv6.format() » ERROR: 1st arg <address> must be a string.");if(!this.validate(o,{verbose:!1}))return console.error(`ipv6.format() » ERROR:  ${o} is not a valid IPv6 address.`);const e=JSON.stringify(n,null,2).replace(/"([^"]+)":/g,"$1:").replace(/"/g,"'").replace(/\n\s*/g," "),t=Object.keys(n).join(", ");var i,a,s=()=>{console.info(`ipv6.format() » Valid options: [ ${t} ]`),console.info("ipv6.format() » If omitted, default settings are: "+e)};if("object"==typeof r){for(const p in r){if(!Object.prototype.hasOwnProperty.call(n,p))return console.error(`ipv6.format() » ERROR: \`${p}\` is an invalid option.`),void s();if("boolean"!=typeof r[p])return console.error(`ipv6.format() » ERROR: [${p}] option can only be \`true\` or \`false\`.`)}r={...n,...r};let e=o;if(e=r.doubleColon?(r.verbose&&console.info("ipv6.format() » Replacing zero series w/ '::'..."),e.replace(/:(?:0+:)+/,"::")):(r.verbose&&console.info("ipv6.format() » Expanding '::' into zero series..."),a=e.split(":").filter(Boolean).length,i=r.leadingZeros?"0000":"0",a=Array(8-a).fill(i).join(":"),e.replace("::",`:${a}:`)),r.leadingZeros){r.verbose&&console.info("ipv6.format() » Adding leading zeros...");var l=e.split(":");for(let e=0;e<l.length;e++)for(;l[e].length<4;)l[e]="0"+l[e];e=l.join(":")}else r.verbose&&console.info("ipv6.format() » Stripping leading zeros..."),e=o.replace(/(^|(?<=:))0+(?!:)/g,"$1");return r.verbose&&(e!==o?console.info("ipv6.format() » IP formatted successfully!"):console.info("ipv6.format() » IP already formatted to specs."),console.info("ipv6.format() » "+e)),e}console.error("ipv6.format() » ERROR: 2nd arg [options] can only be an object of key/values."),console.info("ipv6.format() » Example valid call: ipv6.format('0d::ffff:192.1.56.10/96', { leadingZeros: true, doubleColon: false })"),s()},validate:function(e,o={}){var r={verbose:!0};if("string"!=typeof e)return console.error("ipv6.validate() » ERROR: 1st arg <address> must be a string.");const n=JSON.stringify(r,null,2).replace(/"([^"]+)":/g,"$1:").replace(/"/g,"'").replace(/\n\s*/g," "),t=Object.keys(r).join(", ");var i=()=>{console.info(`ipv6.validate() » Valid options: [ ${t} ]`),console.info("ipv6.validate() » If omitted, default settings are: "+n)};if("object"==typeof o){for(const l in o){if(!Object.prototype.hasOwnProperty.call(r,l))return console.error(`ipv6.validate() » ERROR: \`${l}\` is an invalid option.`),void i();if("boolean"!=typeof o[l])return console.error(`ipv6.validate() » ERROR: [${l}] option can only be \`true\` or \`false\`.`)}(o={...r,...o}).verbose&&console.info("ipv6.validate() » Validating IPv6 address...");const a=e.split(/::?/),s=a[a.length-1];e=!(e.includes("::")&&2<e.split("::").length||/:{3,}/g.test(e)||a.length<2||8<a.length||a.some(e=>!(/^[\dA-Fa-f]{1,4}$/.test(e)||e===s&&p.validate(s.replace(/\/(?:0|(?:[1-2]?\d)|32|96)$/,""),{verbose:!1}))));return o.verbose&&console.info(`ipv6.validate() » IP is ${e?"":"in"}valid IPv6 address!`),e}console.error("ipv6.validate() » ERROR: 2nd arg [options] can only be an object of key/values."),console.info("ipv6.validate() » Example valid call: ipv6.validate('0:0:0:0:0:ffff:192.1.56.10/96', { verbose: false })"),i()}};try{module.exports={ipv4:p,ipv6:e}}catch(e){}try{window.ipv4=p,window.ipv6=e}catch(e){}