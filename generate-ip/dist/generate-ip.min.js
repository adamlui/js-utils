let l;try{l=require("crypto").randomInt}catch(e){const n=window.crypto||window.msCrypto;l=(e,o)=>{var r=n?.getRandomValues(new Uint32Array(1))[0]/4294967295||Math.random();return Math.floor(r*(o-e))+e}}const s={generate:function(o={}){var e={verbose:!0,qty:1};for(const i in o={...e,...o}){if(!Object.prototype.hasOwnProperty.call(e,i))return console.error(`ipv4.generate() » ERROR: \`${i}\` is an invalid option.`),void console.info(`ipv4.generate() » Valid options: [ ${Object.keys(e).join(", ")} ]`);if(["verbose"].includes(i)&&"boolean"!=typeof o[i])return console.error(`ipv4.generate() » ERROR: [${i}] option can only be \`true\` or \`false\`.`);if(["qty"].includes(i)&&(isNaN(o[i])||o[i]<1))return console.error(`ipv4.generate() » ERROR: [${i}] option can only be an integer > 0.`)}o.verbose&&console.info(`ipv4.generate() » Generating IPv4 address${1<o.qty?"es":""}...`);var r=[];if(1<o.qty)for(let e=0;e<o.qty;e++)r.push(this.generate({...o,qty:1,verbose:!1}));else{var n=[];for(let e=0;e<4;e++)n.push(l(0,256));r.push(n.join("."))}var t=1<o.qty?r:r[0];return o.verbose&&(console.info(`ipv4.generate() » IPv4 address${1<o.qty?"es":""} generated!`),console.info(1===o.qty?"ipv4.generate() » "+t:"ipv4.generate() » Check returned array.")),t},validate:function(e,o={}){var r={verbose:!0};if(o={...r,...o},"string"!=typeof e)return console.error("ipv4.validate() » ERROR: 1st arg <address> must be a string.");for(const n in o){if(!Object.prototype.hasOwnProperty.call(r,n))return console.error(`ipv4.validate() » ERROR: \`${n}\` is an invalid option.`),void console.info(`ipv4.validate() » Valid options: [ ${Object.keys(r).join(", ")} ]`);if("boolean"!=typeof o[n])return console.error(`ipv4.validate() » ERROR: [${n}] option can only be set to \`true\` or \`false\`.`)}o.verbose&&console.info("ipv4.validate() » Validating IPv4 address...");e=e.split("."),e=!(4!==e.length||e.some(e=>!/^\d+$/.test(e)||parseInt(e,10)<0||255<parseInt(e,10)));return o.verbose&&console.info(`ipv4.validate() » IP is ${e?"":"in"}valid IPv4 address!`),e}},e={generate:function(o={}){var e={verbose:!0,qty:1,leadingZeros:!1,doubleColon:!0};for(const t in o={...e,...o}){if(!Object.prototype.hasOwnProperty.call(e,t))return console.error(`ipv6.generate() » ERROR: \`${t}\` is an invalid option.`),void console.info(`ipv6.generate() » Valid options: [ ${Object.keys(e).join(", ")} ]`);if(["verbose","leadingZeros","doubleColon"].includes(t)&&"boolean"!=typeof o[t])return console.error(`ipv6.generate() » ERROR: [${t}] option can only be \`true\` or \`false\`.`);if(["qty"].includes(t)&&(isNaN(o[t])||o[t]<1))return console.error(`ipv6.generate() » ERROR: [${t}] option can only be an integer > 0.`)}o.verbose&&console.info(`ipv6.generate() » Generating IPv6 address${1<o.qty?"es":""}...`);var r=[];if(1<o.qty)for(let e=0;e<o.qty;e++)r.push(this.generate({...o,qty:1,verbose:!1}));else{const i=[],{qty:s,...a}=o;for(let e=0;e<8;e++){let o="";for(let e=0;e<4;e++)o+=l(0,16).toString(16);i.push(o)}r.push(this.format(i.join(":"),{...a,verbose:!1}))}var n=1<o.qty?r:r[0];return o.verbose&&(console.info(`ipv6.generate() » IPv6 address${1<o.qty?"es":""} generated!`),console.info(1===o.qty?"ipv6.generate() » "+n:"ipv6.generate() » Check returned array.")),n},format:function(e,o={}){var r,n,t={verbose:!0,leadingZeros:!1,doubleColon:!0};if(o={...t,...o},"string"!=typeof e)return console.error("ipv6.format() » ERROR: 1st arg <address> must be a string.");if(!this.validate(e,{verbose:!1}))return console.error(`ipv6.format() » ERROR:  ${e} is not a valid IPv6 address.`);for(const a in o){if(!Object.prototype.hasOwnProperty.call(t,a))return console.error(`ipv6.format() » ERROR: \`${a}\` is an invalid option.`),void console.info(`ipv6.format() » Valid options: [ ${Object.keys(t).join(", ")} ]`);if("boolean"!=typeof o[a])return console.error(`ipv6.format() » ERROR: [${a}] option can only be set to \`true\` or \`false\`.`)}let i=e;if(i=o.doubleColon?(o.verbose&&console.info("ipv6.format() » Replacing zero series w/ '::'..."),i.replace(/:(?:0+:)+/,"::")):(o.verbose&&console.info("ipv6.format() » Expanding '::' into zero series..."),n=i.split(":").filter(Boolean).length,r=o.leadingZeros?"0000":"0",n=Array(8-n).fill(r).join(":"),i.replace("::",`:${n}:`)),o.leadingZeros){o.verbose&&console.info("ipv6.format() » Adding leading zeros...");var s=i.split(":");for(let e=0;e<s.length;e++)for(;s[e].length<4;)s[e]="0"+s[e];i=s.join(":")}else o.verbose&&console.info("ipv6.format() » Stripping leading zeros..."),i=e.replace(/(^|(?<=:))0+(?!:)/g,"$1");return o.verbose&&(i!==e?console.info("ipv6.format() » IP formatted successfully!"):console.info("ipv6.format() » IP already formatted to specs."),console.info("ipv6.format() » "+i)),i},validate:function(e,o={}){var r={verbose:!0};if(o={...r,...o},"string"!=typeof e)return console.error("ipv6.validate() » ERROR: 1st arg <address> must be a string.");for(const i in o){if(!Object.prototype.hasOwnProperty.call(r,i))return console.error(`ipv6.validate() » ERROR: \`${i}\` is an invalid option.`),void console.info(`ipv6.validate() » Valid options: [ ${Object.keys(r).join(", ")} ]`);if("boolean"!=typeof o[i])return console.error(`ipv6.validate() » ERROR: [${i}] option can only be set to \`true\` or \`false\`.`)}o.verbose&&console.info("ipv6.validate() » Validating IPv6 address...");const n=e.split(/::?/),t=n[n.length-1];e=!(e.includes("::")&&2<e.split("::").length||/:{3,}/g.test(e)||n.length<2||8<n.length||n.some(e=>!(/^[\dA-Fa-f]{1,4}$/.test(e)||e===t&&s.validate(t.replace(/\/(?:0|(?:[1-2]?\d)|32|96)$/,""),{verbose:!1}))));return o.verbose&&console.info(`ipv6.validate() » IP is ${e?"":"in"}valid IPv6 address!`),e}};try{module.exports={ipv4:s,ipv6:e}}catch(e){}try{window.ipv4=s,window.ipv6=e}catch(e){}