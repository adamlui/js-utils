let s;try{s=require("crypto").randomInt}catch(e){const n=window.crypto||window.msCrypto;s=(e,o)=>{var r=n?.getRandomValues(new Uint32Array(1))[0]/4294967295||Math.random();return Math.floor(r*(o-e))+e}}const a={generate:function(o={}){var e={verbose:!0,qty:1};for(const t in o={...e,...o}){if(!Object.prototype.hasOwnProperty.call(e,t))return console.error(`ipv4.generate() » ERROR: \`${t}\` is an invalid option.
`+`ipv4.generate() » Valid options: [ ${Object.keys(e).join(", ")} ]`);if(["verbose"].includes(t)&&"boolean"!=typeof o[t])return console.error(`ipv4.generate() » ERROR: [${t}] option can only be \`true\` or \`false\`.`);if(["qty"].includes(t)&&(isNaN(o[t])||o[t]<1))return console.error(`ipv4.generate() » ERROR: [${t}] option can only be an integer > 0.`)}o.verbose&&console.info(`ipv4.generate() » Generating IPv4 address${1<o.qty?"es":""}...`);var r=[];if(1<o.qty)for(let e=0;e<o.qty;e++)r.push(this.generate({verbose:!1}));else{var n=[];for(let e=0;e<4;e++)n.push(s(0,256));r.push(n.join("."))}return o.verbose&&console.info(`ipv4.generate() » IPv4 address${1<o.qty?"es":""} generated!`+("undefined"!=typeof require&&require.main!==module?`
ipv4.generate() » Check returned ${1<o.qty?"array":"string"}.`:"")),1<o.qty?r:r[0]},validate:function(e,o={}){var r={verbose:!0};if(o={...r,...o},"string"!=typeof e)return console.error("ipv4.validate() » ERROR: 1st arg <address> must be a string.");for(const n in o){if(!Object.prototype.hasOwnProperty.call(r,n))return console.error(`ipv4.validate() » ERROR: \`${n}\` is an invalid option.
`+`ipv4.validate() » Valid options: [ ${Object.keys(r).join(", ")} ]`);if("boolean"!=typeof o[n])return console.error(`ipv4.validate() » ERROR: [${n}] option can only be set to \`true\` or \`false\`.`)}o.verbose&&console.info("ipv4.validate() » Validating IPv4 address...");e=e.split("."),e=!(4!==e.length||e.some(e=>!/^\d+$/.test(e)||parseInt(e,10)<0||255<parseInt(e,10)));return o.verbose&&console.info(`ipv4.validate() » IP is ${e?"":"in"}valid IPv4 address!`),e}},e={generate:function(o={}){var e={verbose:!0,qty:1,leadingZeros:!1,doubleColon:!0};for(const n in o={...e,...o}){if(!Object.prototype.hasOwnProperty.call(e,n))return console.error(`ipv6.generate() » ERROR: \`${n}\` is an invalid option.
`+`ipv6.generate() » Valid options: [ ${Object.keys(e).join(", ")} ]`);if(["verbose","leadingZeros","doubleColon"].includes(n)&&"boolean"!=typeof o[n])return console.error(`ipv6.generate() » ERROR: [${n}] option can only be \`true\` or \`false\`.`);if(["qty"].includes(n)&&(isNaN(o[n])||o[n]<1))return console.error(`ipv6.generate() » ERROR: [${n}] option can only be an integer > 0.`)}o.verbose&&console.info(`ipv6.generate() » Generating IPv6 address${1<o.qty?"es":""}...`);var r=[];if(1<o.qty)for(let e=0;e<o.qty;e++)r.push(this.generate({verbose:!1}));else{const t=[],{qty:i,...a}=o;for(let e=0;e<8;e++){let o="";for(let e=0;e<4;e++)o+=s(0,16).toString(16);t.push(o)}r.push(this.format(t.join(":"),{...a,verbose:!1}))}return o.verbose&&console.info(`ipv6.generate() » IPv6 address${1<o.qty?"es":""} generated!`+("undefined"!=typeof require&&require.main!==module?`
ipv6.generate() » Check returned ${1<o.qty?"array":"string"}.`:"")),1<o.qty?r:r[0]},format:function(e,o={}){var r,n,t={verbose:!0,leadingZeros:!1,doubleColon:!0};if(o={...t,...o},"string"!=typeof e)return console.error("ipv6.format() » ERROR: 1st arg <address> must be a string.");if(!this.validate(e,{verbose:!1}))return console.error(`ipv6.format() » ERROR: 
- ${e} is not a valid IPv6 address.`);for(const s in o){if(!Object.prototype.hasOwnProperty.call(t,s))return console.error(`ipv6.format() » ERROR: \`${s}\` is an invalid option.
`+`ipv6.format() » Valid options: [ ${Object.keys(t).join(", ")} ]`);if("boolean"!=typeof o[s])return console.error(`ipv6.format() » ERROR: [${s}] option can only be \`true\` or \`false\`.`)}let i=e;if(i=o.doubleColon?(o.verbose&&console.info("ipv6.format() » Replacing zero series w/ '::'..."),i.replace(/:(?:0+:)+/,"::")):(o.verbose&&console.info("ipv6.format() » Expanding '::' into zero series..."),n=i.split(":").filter(Boolean).length,r=o.leadingZeros?"0000":"0",n=Array(8-n).fill(r).join(":"),i.replace("::",`:${n}:`)),o.leadingZeros){o.verbose&&console.info("ipv6.format() » Adding leading zeros...");var a=i.split(":");for(let e=0;e<a.length;e++)for(;a[e].length<4;)a[e]="0"+a[e];i=a.join(":")}else o.verbose&&console.info("ipv6.format() » Stripping leading zeros..."),i=e.replace(/(^|(?<=:))0+(?!:)/g,"$1");return o.verbose&&(i!==e?console.info("ipv6.format() » IP formatted successfully!\nipv6.format() » Check returned string."):console.info("ipv6.format() » IP already formatted to specs.")),i},validate:function(e,o={}){var r={verbose:!0};if(o={...r,...o},"string"!=typeof e)return console.error("ipv6.validate() » ERROR: 1st arg <address> must be a string.");for(const i in o){if(!Object.prototype.hasOwnProperty.call(r,i))return console.error(`ipv6.validate() » ERROR: \`${i}\` is an invalid option.
`+`ipv6.validate() » Valid options: [ ${Object.keys(r).join(", ")} ]`);if("boolean"!=typeof o[i])return console.error(`ipv6.validate() » ERROR: [${i}] option can only be \`true\` or \`false\`.`)}o.verbose&&console.info("ipv6.validate() » Validating IPv6 address...");const n=e.split(/::?/),t=n[n.length-1];e=!(e.includes("::")&&2<e.split("::").length||/:{3,}/g.test(e)||n.length<2||8<n.length||n.some(e=>!(/^[\dA-Fa-f]{1,4}$/.test(e)||e===t&&a.validate(t.replace(/\/(?:0|(?:[1-2]?\d)|32|96)$/,""),{verbose:!1}))));return o.verbose&&console.info(`ipv6.validate() » IP is ${e?"":"in"}valid IPv6 address!`),e}};try{module.exports={ipv4:a,ipv6:e}}catch(e){}try{window.ipv4=a,window.ipv6=e}catch(e){}