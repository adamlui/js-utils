/**
 *  © 2024–2025 Adam Lui under the MIT license.
 *  Source: https://code.geolocatejs.org
 *  Documentation: https://docs.geolocatejs.org
 */
async function geolocate(e,n={}){var o={verbose:!0};(e=Array.isArray(e)?e:[e])[0]=e[0]||await fetch("https://ifconfig.me/ip").then(e=>e.text()).catch(()=>fetch("http://ip-api.com/json/").then(e=>e.json()).then(e=>e.query)).catch(async()=>{try{var e=require("child_process")["exec"],o=require("util")["promisify"],{stdout:t,stderr:r}=await o(e)("curl -s ifconfig.me");return r?console.error("geolocate() »",r):t.trim()}catch(e){console.error("geolocate() »",e)}});for(const t of e){n.verbose&&console.info(`geolocate() » Validating ${t}...`);let o;try{o=require("generate-ip").ipv4.validate}catch(e){await import("https://cdn.jsdelivr.net/npm/generate-ip/dist/generate-ip.min.js"),o=ipv4.validate}if(o&&!o(t,{verbose:!1}))return console.error(`geolocate() » ERROR: ${t} is not a valid IPv4 address.`)}if(validateOptions(n,o,"https://docs.geolocatejs.org/#locateips-options","geolocate('8.8.8.8', { verbose: false })")){n={...o,...n};try{var c=[];for(const i of e){n.verbose&&console.info(`geolocate() » Fetching geolocation data for ${i}...`);let{status:e,org:o,as:t,query:r,...a}=await(await fetchData("http://ip-api.com/json/"+i)).json();a={ip:i,...a},c.push(a)}return n.verbose&&"undefined"!=typeof window&&console.info("geolocate() » Success! Check returned array."),c}catch(e){console.error("geolocate() » ERROR:",e.message)}}}function fetchData(r){return"undefined"==typeof fetch?new Promise((t,o)=>{try{var e=r.match(/^([^:]+):\/\//)[1];/^https?$/.test(e)||o(new Error("Invalid fetchData() URL.")),require(e).get(r,e=>{let o="";e.on("data",e=>o+=e),e.on("end",()=>t({json:()=>JSON.parse(o)}))}).on("error",e=>o(new Error(e.message)))}catch(e){o(new Error("Environment not supported."))}}):fetch(r)}function validateOptions(e,o,t,r){const a=JSON.stringify(o,null,2).replace(/"([^"]+)":/g,"$1:").replace(/"/g,"'").replace(/\n\s*/g," "),n=Object.keys(o).join(", "),c=Object.keys(o).filter(e=>"boolean"==typeof o[e]),i=`${validateOptions.caller?.name||"validateOptions"}() » `;var s=r.split(",").findIndex(e=>e.trim().startsWith("{"))+1,l=(s+=["st","nd","rd"][s-1]||"th",()=>{console.info(i+`Valid options: [ ${n} ]`),console.info(i+"If omitted, default settings are: "+a)}),p=()=>{console.info(i+"For more help, please visit "+t)};if("object"!=typeof e)return console.error(i+`ERROR: ${"0th"==s?"[O":s+" arg [o"}ptions] can only be an object of key/values.`),console.info(i+"Example valid call: "+r),l(),p(),!1;for(const f in e){if(!Object.prototype.hasOwnProperty.call(o,f))return console.error(i+`ERROR: \`${f}\` is an invalid option.`),l(),p(),!1;if(c.includes(f)&&"boolean"!=typeof e[f])return console.error(i+`ERROR: [${f}] option can only be \`true\` or \`false\`.`),p(),!1}return!0}const geoAliases={geolocate:["Geolocate","geoLocate","GeoLocate","locate","Locate"]};try{module.exports={geolocate:geolocate}}catch(e){}try{window.geo={geolocate:geolocate}}catch(e){}for(const $ in geoAliases){try{geoAliases[$].forEach(e=>module.exports[e]=module.exports[$])}catch(e){}try{geoAliases[$].forEach(e=>window.geo[e]=window.geo[$])}catch(e){}}