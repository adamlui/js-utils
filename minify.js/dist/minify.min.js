#!/usr/bin/env node
const t=require("fs"),l=require("path"),i=require("uglify-js");function c(o,s={}){var e={recursive:!0,verbose:!0,dotFolders:!1,dotFiles:!1};if("string"!=typeof o)return console.error("findJS() » ERROR: 1st arg <searchDir> must be a string.");var r=l.resolve(process.cwd(),o);if(t.existsSync(r)){if(f(s,e,"findJS('assets/js', { verbose: false, dotFolders: true })")){s={...e,...s};const i=t.readdirSync(o),n=[];return s.verbose&&!s.isRecursing&&console.info("findJS() » Searching for unminified JS files..."),i.forEach(e=>{var r=l.resolve(o,e);t.statSync(r).isDirectory()&&"node_modules"!=e&&(s.dotFolders||!e.startsWith("."))&&s.recursive?n.push(...c(r,{...s,isRecursing:!0})):!/\.js(?<!\.min\.js)$/.test(e)||!s.dotFiles&&e.startsWith(".")||n.push(r)}),!s.isRecursing&&s.verbose&&(console.info("findJS() » Search complete! "+(0===n.length?"No":n.length)+` file${1<n.length?"s":""} found.`),"minify"===c.caller.name||require.main.filename.endsWith("cli.js")||console.info("findJS() » Check returned array.")),s.isRecursing||0<n.length?n:[]}}else console.error("findJS() » ERROR: 1st arg <searchDir> must be an existing directory."),console.error(`findJS() » ${r} does not exist.`)}function e(e,o={}){var r={recursive:!0,verbose:!0,dotFolders:!1,dotFiles:!1,mangle:!0};if("string"!=typeof e)return console.error("minify() » ERROR: 1st arg <input> must be a string.");if(f(o,r,"minify('assets/js', { recursive: false, mangle: false })")){const s={mangle:!!(o={...r,...o}).mangle&&{toplevel:!0}};return t.existsSync(e)?e.endsWith(".js")?(o.verbose&&console.info(`minify() » Minifying ${e}...`),(r=i.minify(t.readFileSync(e,"utf8"),s)).error&&console.error("minify() » ERROR: "+r.error.message),{code:r.code,srcPath:l.resolve(process.cwd(),e),error:r.error}):c(e,{recursive:o.recursive,verbose:o.verbose,dotFolders:o.dotFolders,dotFiles:o.dotFiles})?.map(e=>{o.verbose&&console.info(`minify() » Minifying ${e}...`);var r=t.readFileSync(e,"utf8"),r=i.minify(r,s);return r.error&&console.error("minify() » ERROR: "+r.error.message),{code:r.code,srcPath:e,error:r.error}}).filter(e=>!e.error):(o.verbose&&console.info("minify() » Minifying passed source code..."),(r=i.minify(e,s)).error&&console.error("minify() » ERROR: "+r.error.message),{code:r.code,srcPath:void 0,error:r.error})}}function f(e,r,o){const s=(f.caller?.name||"validateOptions")+"() » ",i=JSON.stringify(r,null,2).replace(/"([^"]+)":/g,"$1:").replace(/"/g,"'").replace(/\n\s*/g," "),n=Object.keys(r).join(", "),t=Object.keys(r).filter(e=>"boolean"==typeof r[e]),l=Object.keys(r).filter(e=>Number.isInteger(r[e]));var c=()=>{console.info(s+`Valid options: [ ${n} ]`),console.info(s+"If omitted, default settings are: "+i)};if("object"!=typeof e)return console.error(s+"ERROR: [options] can only be an object of key/values."),console.info(s+"Example valid call: "+o),c(),!1;for(const a in e){if("isRecursing"!=a&&!Object.prototype.hasOwnProperty.call(r,a))return console.error(s+`ERROR: \`${a}\` is an invalid option.`),c(),!1;if(t.includes(a)&&"boolean"!=typeof e[a])return console.error(s+`ERROR: [${a}] option can only be \`true\` or \`false\`.`),!1;if(l.includes(a)&&(e[a]=parseInt(e[a],10),isNaN(e[a])||e[a]<1))return console.error(s+`ERROR: [${a}] option can only be an integer > 0.`),!1}return!0}module.exports={minify:e,findJS:c};