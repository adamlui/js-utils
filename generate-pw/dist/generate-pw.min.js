let w;try{w=require("crypto").randomInt}catch(e){const t=window.crypto||window.msCrypto;w=(e,r)=>{var o=t?.getRandomValues(new Uint32Array(1))[0]/4294967295||Math.random();return Math.floor(o*(r-e))+e}}const m={lower:"abcdefghijklmnopqrstuvwxyz",upper:"ABCDEFGHIJKLMNOPQRSTUVWXYZ",numbers:"0123456789",symbols:"!@#$%^&*()-_=+[]{}/\\|;:'\",.<>?"};function d(t={}){var e={verbose:!0,length:8,qty:1,charset:"",exclude:"",numbers:!1,symbols:!1,lowercase:!0,uppercase:!0,strict:!1};t={...e,...t};const r=JSON.stringify(e),o=Object.keys(e).join(", ");var s=()=>{console.info(`generatePassword() » Valid options: [ ${o} ]`),console.info("generatePassword() » If omitted, default settings are: "+r)};for(const l in t){if("0"==l)return console.error("generatePassword() » ERROR: 1st arg [options] can only be an object of key/values."),console.info("generatePassword() » Example valid call: generatePassword({ verbose: false, numbers: true })"),void s();if(!Object.prototype.hasOwnProperty.call(e,l))return console.error(`generatePassword() » ERROR: \`${l}\` is an invalid option.`),void s();if(["length","qty"].includes(l)){if(t[l]=parseInt(t[l],10),isNaN(t[l])||t[l]<1)return console.error(`generatePassword() » ERROR: [${l}] option can only be \`true\` or \`false\`.`)}else if(["numbers","symbols","lowercase","uppercase","strict"].includes(l)&&"boolean"!=typeof t[l])return console.error(`generatePassword() » ERROR: [${l}] option can only be \`true\` or \`false\`.`)}if(1<t.qty){const{qty:c,...f}=t;return g(c,f)}{var n,a="generatePasswords"===d.caller?.name;t.verbose&&!a&&console.info("generatePassword() » Initializing character set...");let r=t.charset||(t.numbers?m.numbers:"")+(t.symbols?m.symbols:"")+(t.lowercase?m.lower:"")+(t.uppercase?m.upper:""),o=(""===r&&(r=m.lower+m.upper),t.exclude&&(t.verbose&&!a&&console.info("generatePassword() » Removing excluded characters..."),r=r.replace(new RegExp(`[${t.exclude}]`,"g"),"")),t.verbose&&!a&&console.info("generatePassword() » Generating password..."),"");for(let e=0;e<t.length;e++){var i=w(0,r.length);o+=r.charAt(i)}return t.strict&&(t.verbose&&!a&&console.info("generatePassword() » Enforcing strict mode..."),n=["number","symbol","lower","upper"].filter(e=>t[e+"s"]||t[e+"case"]),o=p(o,n)),t.verbose&&!a&&(console.info("generatePassword() » Password generated!"),"undefined"==typeof require||require.main.filename.endsWith("cli.js")||console.info("generatePassword() » Check returned string.")),o}}function g(r,o={}){var e={verbose:!0,length:8,charset:"",exclude:"",numbers:!1,symbols:!1,lowercase:!0,uppercase:!0,strict:!1};if(o={...e,...o},r=parseInt(r,10),isNaN(r)||r<1)return console.error("generatePasswords() » ERROR: 1st arg <qty> can only be an integer > 0.");const t=JSON.stringify(e),s=Object.keys(e).join(", ");var n=()=>{console.info(`generatePasswords() » Valid options: [ ${s} ]`),console.info("generatePasswords() » If omitted, default settings are: "+t)};for(const i in o){if("0"==i)return console.error("generatePasswords() » ERROR: 2nd arg [options] can only be an object of key/values."),console.info("generatePasswords() » Example valid call: generatePasswords(3, { verbose: false, symbols: true })"),void n();if(!Object.prototype.hasOwnProperty.call(e,i))return console.error(`generatePasswords() » ERROR: \`${i}\` is an invalid option.`),void n()}if(o.length=parseInt(o.length),isNaN(o.length)||o.length<1)return console.error("generatePasswords() » ERROR: [length] option can only be an integer > 0.");for(const l of["numbers","symbols","lowercase","uppercase","strict"])if("boolean"!=typeof o[l])return console.error(`generatePasswords() » ERROR: [${l}] option can only be \`true\` or \`false\`.`);o.verbose&&console.info(`generatePasswords() » Generating password${1<r?"s":""}...`);var a=[];for(let e=0;e<r;e++)a.push(d(o));return o.verbose&&console.info(`generatePasswords() » Password${1<r?"s":""} generated!`),"undefined"==typeof require||require.main.filename.endsWith("cli.js")||console.info("generatePasswords() » Check returned array."),a}function p(r,o=["number","symbol","lower","upper"],e={}){var t={verbose:!0};if(e={...t,...e},"string"!=typeof r)return console.error("strictify() » ERROR: 1st arg <password> must be a string.");var s=["number","symbol","lower","upper"];for(const u of o=Array.isArray(o)?o:[o])if(!s.includes(u))return console.error(`strictify() » ERROR: 2nd arg \`${u}\` is an invalid character type.`),console.info(`strictify() » Valid character types: [ ${s.join(", ")} ]`),void console.error("strictify() » Note: If omitted, all character types will be required.");const n=JSON.stringify(t),a=Object.keys(t).join(", ");var i=()=>{console.info(`strictify() » Valid options: [ ${a} ]`),console.info("strictify() » If omitted, default settings are: "+n)};for(const y in e){if("0"==y)return console.error("strictify() » ERROR: 3nd arg [options] can only be an object of key/values."),console.info("strictify() » Example valid call: strictify('pa55word', ['symbol', 'upper'], { verbose: false })"),void i();if(!Object.prototype.hasOwnProperty.call(t,y))return console.error(`strictify() » ERROR: \`${y}\` is an invalid option.`),void i();if("boolean"!=typeof e[y])return console.error(`strictify() » ERROR: [${y}] option can only be set to \`true\` or \`false\`.`)}var l={};for(const b of o)l["has"+b.charAt(0).toUpperCase()+b.slice(1)]=!1;for(let e=0;e<r.length;e++)for(const h of o)(m[h]||m[h+"s"]).includes(r.charAt(e))&&(l["has"+h.charAt(0).toUpperCase()+h.slice(1)]=!0);e.verbose&&console.info("strictify() » Strictifying password...");var c=Math.min(r.length,o.length),f=[];let d=0,g=r;for(const v of o)if(d<c&&!l["has"+v.charAt(0).toUpperCase()+v.slice(1)]){let e;for(;e=w(0,r.length),f.includes(e););f.push(e);var p=m[v]||m[v+"s"];g=g.substring(0,e)+p.charAt(w(0,p.length))+g.substring(e+1),d++}return e.verbose&&(0<d?(console.info("strictify() » Password is now strict!"),console.info("strictify() » Check returned string.")):(console.info(`strictify() » Password already includes ${o.join(" + ")} characters!`),console.info("strictify() » No modifications made."))),g}function e(e,r={}){var o={minLength:8,minLower:1,minUpper:1,minNumber:1,minSymbol:1},t={verbose:!0};if(r={...t,...r},"string"!=typeof e)return console.error("validateStrength() » ERROR: 1st arg <password> must be a string.");const s=JSON.stringify(t),n=Object.keys(t).join(", ");var a=()=>{console.info(`validateStrength() » Valid options: [ ${n} ]`),console.info("validateStrength() » If omitted, default settings are: "+s)};for(const f in r){if("0"==f)return console.error("validateStrength() » ERROR: 2nd arg [options] can only be an object of key/values."),console.info("validateStrength() » Example valid call: validateStrength('pa55word', { verbose: false })"),void a();if(!Object.prototype.hasOwnProperty.call(t,f))return console.error(`validateStrength() » ERROR: \`${f}\` is an invalid option.`),void a();if("boolean"!=typeof r[f])return console.error(`validateStrength() » ERROR: [${f}] option can only be set to \`true\` or \`false\`.`)}r.verbose&&console.info("validateStrength() » Validating password strength...");var i={lower:0,upper:0,number:0,symbol:0};for(const d of e)for(const g of Object.keys(i))(m[g]||m[g+"s"]).includes(d)&&i[g]++;var l=[];e.length<o.minLength&&l.push(`Make it at least ${o.minLength} characters long.`);for(const p of Object.keys(i))i[p]<o["min"+p.charAt(0).toUpperCase()+p.slice(1)]&&l.push("Include at least one "+p+`${["upper","lower"].includes(p)?"case letter":""}.`);let c=0;c+=e.length>=o.minLength?20:0;for(const u of Object.keys(i))c+=i[u]>=o["min"+u.charAt(0).toUpperCase()+u.slice(1)]?20:0;return r.verbose&&(console.info("validateStrength() » Password strength validated!"),console.info("validateStrength() » Check returned object for score/recommendations.")),{strengthScore:c,recommendations:l,isGood:80<=c}}try{module.exports={generatePassword:d,generatePasswords:g,strictify:p,validateStrength:e}}catch(e){}try{window.pw={generatePassword:d,generatePasswords:g,strictify:p,validateStrength:e}}catch(e){}